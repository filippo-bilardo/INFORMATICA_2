### **1. Introduzione alle Strutture Dati**

#### **1.1 Cosa sono le Strutture Dati?**
Le **strutture dati** sono modi organizzati di memorizzare, gestire e organizzare i dati in modo efficiente, per facilitare operazioni come l’accesso, la modifica, l’inserimento e la cancellazione. Sono uno strumento fondamentale per risolvere problemi computazionali in modo ottimizzato, riducendo il tempo e lo spazio richiesti dalle operazioni.

- **Definizione formale**: Una struttura dati è una collezione di dati organizzata in un formato specifico, che permette di eseguire operazioni su di essi in modo efficiente.
- **Esempi comuni**: array, liste collegate, stack, code, alberi, grafi, tabelle hash.
- **Scopo principale**: Ottimizzare le operazioni sui dati, bilanciando tempo di esecuzione (complessità temporale) e uso della memoria (complessità spaziale).

---

#### **1.2 Importanza delle Strutture Dati nella Programmazione**
Le strutture dati sono fondamentali per la programmazione perché:  
1. **Migliorano l’efficienza**: Consentono di eseguire operazioni complesse in tempi ridotti. Ad esempio, una ricerca binaria su un array ordinato è molto più veloce di una ricerca lineare.  
2. **Organizzano i dati**: Rendono il codice più leggibile, modulare e manutenibile.  
3. **Risolvono problemi complessi**: Molti algoritmi avanzati (es. Dijkstra per i grafi, Huffman per la compressione) si basano su strutture dati specifiche.  
4. **Ottimizzano l’uso delle risorse**: Riducendo il consumo di memoria e migliorando le prestazioni.

**Esempio pratico**:  
- **Problema**: Trovare un numero in una lista di 1 milione di elementi.  
- **Senza strutture dati**: Una ricerca lineare richiede O(n), ovvero fino a 1 milione di operazioni.  
- **Con una struttura dati efficiente**: Un albero binario di ricerca (BST) riduce la complessità a O(log n), ovvero circa 20 operazioni.

---

#### **1.3 Classificazione delle Strutture Dati**
Le strutture dati possono essere classificate in due categorie principali:  

1. **Strutture Dati Lineari**:  
   - I dati sono organizzati in una sequenza lineare.  
   - Ogni elemento ha un predecessore e un successore (tranne il primo e l’ultimo).  
   - **Esempi**: array, liste collegate, stack, code.  

2. **Strutture Dati Non Lineari**:  
   - I dati non seguono una sequenza lineare.  
   - Gli elementi sono organizzati in modo gerarchico o reticolare.  
   - **Esempi**: alberi, grafi, tabelle hash.  

**Tabella di Confronto**:  
| **Tipo**         | **Esempi**                  | **Vantaggi**                              | **Svantaggi**                          |  
|-------------------|-----------------------------|-------------------------------------------|----------------------------------------|  
| **Lineari**       | Array, Liste, Stack, Code   | Semplicità, accesso diretto (array)       | Dimensioni fisse (array), overhead (liste) |  
| **Non Lineari**   | Alberi, Grafi, Tabelle Hash | Ricerca e accesso efficiente              | Complessità implementativa             |  

---

#### **1.4 Complessità Temporale e Spaziale: Big-O Notation**
La **complessità** misura l’efficienza di un algoritmo o di una struttura dati in termini di tempo (complessità temporale) e spazio (complessità spaziale).  
- **Notazione Big-O**: Descrive il comportamento asintotico di un algoritmo nel caso peggiore.  

**Esempi di Complessità Temporale**:  
- **O(1)**: Accesso diretto a un elemento in un array.  
- **O(n)**: Ricerca lineare in una lista non ordinata.  
- **O(log n)**: Ricerca binaria in un array ordinato.  
- **O(n²)**: Ordinamento a bolle (bubble sort).  

**Esempio Pratico**:  
```cpp
// Ricerca binaria in un array ordinato (O(log n))
int ricercaBinaria(int arr[], int n, int chiave) {
    int sinistra = 0, destra = n - 1;
    while (sinistra <= destra) {
        int medio = sinistra + (destra - sinistra) / 2;
        if (arr[medio] == chiave) return medio;
        if (arr[medio] < chiave) sinistra = medio + 1;
        else destra = medio - 1;
    }
    return -1; // Non trovato
}
```

**Complessità Spaziale**:  
- Misura la quantità di memoria utilizzata da un algoritmo o una struttura dati.  
- Esempio: un array di dimensione n ha complessità spaziale O(n).

---

#### **1.5 Esempi Pratici**
1. **Array**:  
   - Memorizza dati omogenei in modo contiguo.  
   - Accesso diretto tramite indice.  
   ```cpp
   int numeri[] = {1, 2, 3, 4, 5};
   cout << numeri[2]; // Output: 3
   ```

2. **Liste Collegate**:  
   - Ogni elemento (nodo) contiene dati e un puntatore al prossimo nodo.  
   - Flessibile nelle dimensioni, ma overhead di memoria.  
   ```cpp
   struct Nodo {
       int dato;
       Nodo* next;
   };
   Nodo* testa = new Nodo{1, nullptr};
   ```

3. **Stack (Pila)**:  
   - Segue il principio LIFO (Last In, First Out).  
   - Operazioni: `push` (inserisce), `pop` (rimuove).  
   ```cpp
   stack<int> pila;
   pila.push(10);
   pila.push(20);
   cout << pila.top(); // Output: 20
   pila.pop();
   ```

4. **Coda**:  
   - Segue il principio FIFO (First In, First Out).  
   - Operazioni: `enqueue` (inserisce), `dequeue` (rimuove).  
   ```cpp
   queue<int> coda;
   coda.push(10);
   coda.push(20);
   cout << coda.front(); // Output: 10
   coda.pop();
   ```

---

#### **1.6 Errori Comuni**
1. **Uso improprio di array**:  
   - Accesso fuori dai limiti (es. `arr[10]` in un array di dimensione 5).  
   - Dimenticare di gestire la memoria dinamica (es. `malloc` senza `free`).  

2. **Complessità non ottimale**:  
   - Usare una ricerca lineare (O(n)) quando è possibile una ricerca binaria (O(log n)).  

3. **Scelta sbagliata della struttura dati**:  
   - Usare una lista collegata per operazioni di accesso frequente (O(n)) invece di un array (O(1)).  

---

#### **1.7 Domande per Autovalutazione**
1. Qual è la differenza tra una struttura dati lineare e una non lineare?  
2. Perché la notazione Big-O è importante nella scelta di una struttura dati?  
3. Quale struttura dati useresti per implementare una coda di messaggi? Perché?  

---

#### **1.8 Esercizio Proposto**
**Task**: Implementare una funzione che, dato un array di numeri interi, trovi il valore massimo e minimo.  
- **Input**: `int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};`  
- **Output**: `Max: 9, Min: 1`  
- **Suggerimento**: Usa un ciclo per scorrere l’array e confrontare i valori.  

---

#### **Tips & Tricks**
- **Scegli la struttura dati giusta**:  
  - Se hai bisogno di accesso casuale: usa un array.  
  - Se hai bisogno di flessibilità nelle dimensioni: usa una lista collegata.  
- **Ottimizza per il caso peggiore**: Analizza sempre la complessità temporale e spaziale.  

---

### **1. Introduzione alle Strutture Dati Dinamiche**

Le **strutture dati dinamiche** sono strutture dati la cui dimensione può cambiare durante l’esecuzione di un programma, a differenza delle strutture dati statiche (come gli array) che hanno una dimensione fissa. Questa flessibilità le rende particolarmente utili in contesti in cui la quantità di dati non è nota a priori o cambia frequentemente.

---

#### **1.1 Cosa sono le Strutture Dati Dinamiche?**
Le strutture dati dinamiche sono collezioni di dati organizzati in modo da poter crescere o ridursi dinamicamente durante l’esecuzione del programma. A differenza degli array, che richiedono una dimensione fissa al momento della creazione, le strutture dinamiche allocano e deallocano memoria in base alle esigenze.

**Esempi comuni**:  
- Liste collegate (linked lists)  
- Stack (pile)  
- Code (queue)  
- Alberi (trees)  
- Grafi (graphs)  

---

#### **1.2 Vantaggi delle Strutture Dati Dinamiche**
1. **Flessibilità**: Possono crescere o ridursi in base alle esigenze del programma.  
2. **Efficienza nell’uso della memoria**: La memoria viene allocata solo quando necessario, riducendo gli sprechi.  
3. **Gestione di dati complessi**: Ideali per rappresentare relazioni complesse tra dati (es. alberi, grafi).  

---

#### **1.3 Svantaggi delle Strutture Dati Dinamiche**
1. **Overhead di memoria**: Ogni elemento richiede memoria aggiuntiva per memorizzare i puntatori.  
2. **Complessità implementativa**: La gestione dei puntatori e della memoria può essere più complessa rispetto alle strutture statiche.  
3. **Accesso casuale lento**: L’accesso a un elemento specifico può richiedere tempo O(n), a differenza degli array che hanno accesso O(1).  

---

#### **1.4 Confronto tra Strutture Statiche e Dinamiche**
| **Caratteristica**       | **Strutture Statiche (es. Array)** | **Strutture Dinamiche (es. Liste)** |  
|--------------------------|------------------------------------|-------------------------------------|  
| **Dimensione**           | Fissa                             | Dinamica                            |  
| **Accesso Casuale**      | O(1)                              | O(n)                                |  
| **Inserimento/Cancellazione** | O(n) (spostamento elementi)       | O(1) in testa/coda, O(n) in mezzo   |  
| **Uso Memoria**          | Contiguo, nessun overhead         | Overhead per i puntatori            |  

---

#### **1.5 Esempi Pratici**
1. **Liste Collegate**:  
   - Ogni nodo contiene dati e un puntatore al prossimo nodo.  
   - Ideali per inserimenti/cancellazioni frequenti.  
   ```cpp
   struct Nodo {
       int dato;
       Nodo* next;
   };
   ```

2. **Stack (Pile)**:  
   - Segue il principio LIFO (Last In, First Out).  
   - Operazioni: `push` (inserisce), `pop` (rimuove).  
   ```cpp
   stack<int> pila;
   pila.push(10);
   pila.pop();
   ```

3. **Code (Queue)**:  
   - Segue il principio FIFO (First In, First Out).  
   - Operazioni: `enqueue` (inserisce), `dequeue` (rimuove).  
   ```cpp
   queue<int> coda;
   coda.push(10);
   coda.pop();
   ```

4. **Alberi (Trees)**:  
   - Struttura gerarchica con nodi padre e figli.  
   - Esempio: alberi binari di ricerca (BST).  
   ```cpp
   struct Nodo {
       int dato;
       Nodo* sinistra;
       Nodo* destra;
   };
   ```

---

#### **1.6 Best Practice**
1. **Gestione della Memoria**:  
   - Usa `new` e `delete` in C++ per allocare e deallocare memoria.  
   - Implementa distruttori per evitare memory leak.  

2. **Controllo dei Puntatori**:  
   - Verifica sempre se un puntatore è `nullptr` prima di dereferenziarlo.  

3. **Modularità**:  
   - Separa la logica della struttura dati in una classe dedicata.  

---

#### **1.7 Domande di Autovalutazione (Scelta Multipla)**

1. **Qual è la complessità temporale dell’inserimento in testa in una lista collegata?**  
   a) O(1)  
   b) O(n)  
   c) O(log n)  
   d) O(n²)  

2. **Cosa succede se si cancella un nodo in una lista collegata senza aggiornare i puntatori?**  
   a) La lista diventa circolare.  
   b) Si verifica un memory leak.  
   c) La lista si inverte.  
   d) Non succede nulla.  

3. **Quale struttura dati è più efficiente per l’accesso casuale?**  
   a) Lista collegata  
   b) Array  
   c) Stack  
   d) Coda  

**Risposte**:  
1. **a) O(1)** – L’inserimento in testa richiede tempo costante.  
2. **b) Si verifica un memory leak** – Il nodo cancellato non viene deallocato correttamente.  
3. **b) Array** – L’accesso casuale in un array è O(1), mentre in una lista è O(n).  

---

#### **1.8 Proposte di Esercizi**

1. **Implementazione di una Lista Collegata**:  
   Scrivi una lista collegata che supporti l’inserimento in testa, la cancellazione e la stampa degli elementi.  

2. **Gestione di uno Stack**:  
   Implementa uno stack che supporti le operazioni `push`, `pop` e `peek`.  

3. **Simulazione di una Coda**:  
   Scrivi una coda che supporti le operazioni `enqueue`, `dequeue` e la stampa degli elementi.  
