### **2. Liste concatenate (Linked Lists)**

Le **liste concatenate** sono una delle strutture dati fondamentali nella programmazione, ampiamente utilizzate per la loro flessibilità e dinamicità. A differenza degli array, che memorizzano i dati in modo contiguo, le liste concatenate organizzano i dati in nodi separati, collegati tra loro tramite puntatori. Questo le rende particolarmente adatte per situazioni in cui la dimensione dei dati non è nota a priori o cambia frequentemente.

#### **2.1 Introduzione alle Liste concatenate**
Una **lista collegata** è una struttura dati lineare in cui ogni elemento (detto **nodo**) contiene due parti:  
1. **Dato**: Il valore memorizzato nel nodo.  
2. **Puntatore**: Un riferimento al nodo successivo (o precedente, nel caso di liste doppiamente concatenate).  

Il primo nodo della lista è chiamato **testa** (head), mentre l’ultimo nodo punta a `nullptr` (o `NULL`), indicando la fine della lista.

A differenza degli array, le liste concatenate non memorizzano i dati in modo contiguo, ma ogni nodo è allocato dinamicamente e collegato tramite puntatori.  

**Esempio di una lista singolarmente collegata**:  
```
Testa -> [Dato: 1 | Puntatore: ->] [Dato: 2 | Puntatore: ->] [Dato: 3 | Puntatore: nullptr]
```
---

#### **2.2 Tipi di Liste concatenate**
1. **Liste Singolarmente concatenate**:  
   - Ogni nodo punta solo al successivo.  
   - Esempio: `A -> B -> C -> nullptr`.  

2. **Liste Doppiamente concatenate**:  
   - Ogni nodo punta sia al successivo che al precedente.  
   - Esempio: `nullptr <-> A <-> B <-> C <-> nullptr`.  

3. **Liste Circolari**:  
   - L’ultimo nodo punta al primo, formando un ciclo.  
   - Esempio: `A -> B -> C -> A`.  

---

#### **2.3 Operazioni sulle Liste concatenate**
Le operazioni principali sono:  
1. **Inserimento**:  
   - In testa, in coda o in una posizione specifica.  
2. **Cancellazione**:  
   - Rimuovere un nodo in base al valore o alla posizione.  
3. **Ricerca**:  
   - Trovare un nodo in base al valore.  
4. **Attraversamento**:  
   - Visitare tutti i nodi della lista.  

---

#### **2.4 Implementazione di una Lista Singolarmente Collegata**
Ecco un esempio di implementazione in C++:  

```cpp
#include <iostream>
using namespace std;

struct Nodo {
    int dato;
    Nodo* next;
};

class ListaCollegata {
private:
    Nodo* testa;

public:
    ListaCollegata() : testa(nullptr) {}

    // Inserimento in testa
    void inserisciInTesta(int valore) {
        Nodo* nuovoNodo = new Nodo{valore, testa};
        testa = nuovoNodo;
    }

    // Cancellazione di un nodo
    void cancella(int valore) {
        Nodo* corrente = testa;
        Nodo* precedente = nullptr;

        while (corrente != nullptr && corrente->dato != valore) {
            precedente = corrente;
            corrente = corrente->next;
        }

        if (corrente == nullptr) return; // Nodo non trovato

        if (precedente == nullptr) {
            testa = corrente->next; // Cancella il primo nodo
        } else {
            precedente->next = corrente->next;
        }

        delete corrente;
    }

    // Ricerca di un nodo
    bool cerca(int valore) {
        Nodo* corrente = testa;
        while (corrente != nullptr) {
            if (corrente->dato == valore) return true;
            corrente = corrente->next;
        }
        return false;
    }

    // Stampa della lista
    void stampa() {
        Nodo* corrente = testa;
        while (corrente != nullptr) {
            cout << corrente->dato << " -> ";
            corrente = corrente->next;
        }
        cout << "nullptr" << endl;
    }

    // Distruttore per liberare la memoria
    ~ListaCollegata() {
        while (testa != nullptr) {
            Nodo* temp = testa;
            testa = testa->next;
            delete temp;
        }
    }
};

int main() {
    ListaCollegata lista;
    lista.inserisciInTesta(3);
    lista.inserisciInTesta(2);
    lista.inserisciInTesta(1);
    lista.stampa(); // Output: 1 -> 2 -> 3 -> nullptr

    lista.cancella(2);
    lista.stampa(); // Output: 1 -> 3 -> nullptr

    cout << "Cerca 3: " << (lista.cerca(3) ? "Trovato" : "Non trovato") << endl; // Output: Trovato
}
```

---

#### **2.5 Best Practice**
1. **Gestione della memoria**:  
   - Usa `new` e `delete` per allocare e deallocare nodi.  
   - Implementa un distruttore per evitare memory leak.  

2. **Controllo dei puntatori**:  
   - Verifica sempre se un puntatore è `nullptr` prima di dereferenziarlo.  

3. **Modularità**:  
   - Separa la logica della lista in una classe dedicata.  

---

#### **2.6 Tips & Tricks**
1. **Dummy Node**:  
   - Usa un nodo fittizio (dummy) per semplificare le operazioni di inserimento/cancellazione in testa.  

2. **Doppio Puntatore**:  
   - Usa un puntatore a puntatore per gestire l’inserimento/cancellazione senza casi speciali.  

3. **Ricorsione**:  
   - Alcune operazioni (es. inversione della lista) possono essere implementate in modo ricorsivo.  

---

#### **2.7 Domande di Autovalutazione (Scelta Multipla)**

1. **Qual è la complessità temporale dell’inserimento in testa in una lista singolarmente collegata?**  
   a) O(1)  
   b) O(n)  
   c) O(log n)  
   d) O(n²)  

2. **Cosa succede se si cancella un nodo in una lista singolarmente collegata senza aggiornare i puntatori?**  
   a) La lista diventa circolare.  
   b) Si verifica un memory leak.  
   c) La lista si inverte.  
   d) Non succede nulla.  

3. **Quale struttura dati è più efficiente per l’accesso casuale?**  
   a) Lista collegata  
   b) Array  
   c) Stack  
   d) Coda  

**Risposte**:  
1. **a) O(1)** – L’inserimento in testa richiede tempo costante.  
2. **b) Si verifica un memory leak** – Il nodo cancellato non viene deallocato correttamente.  
3. **b) Array** – L’accesso casuale in un array è O(1), mentre in una lista è O(n).  

---

#### **2.8 Proposte di Esercizi**

1. **Inversione di una Lista**:  
   Scrivi una funzione per invertire una lista singolarmente collegata.  
   **Input**: `1 -> 2 -> 3 -> nullptr`  
   **Output**: `3 -> 2 -> 1 -> nullptr`  

2. **Rimozione dei Duplicati**:  
   Scrivi una funzione per rimuovere i duplicati da una lista collegata non ordinata.  
   **Input**: `1 -> 2 -> 2 -> 3 -> nullptr`  
   **Output**: `1 -> 2 -> 3 -> nullptr`  

3. **Intersezione di Due Liste**:  
   Scrivi una funzione per trovare l’intersezione di due liste concatenate.  
   **Input**: `1 -> 2 -> 3 -> nullptr` e `2 -> 3 -> 4 -> nullptr`  
   **Output**: `2 -> 3 -> nullptr`  

4. **Inserimento in Coda**:  
   Scrivi una funzione per inserire un elemento in coda a una lista singolarmente collegata.  
   **Input**: `1 -> 2 -> 3 -> nullptr`, valore da inserire: `4`  
   **Output**: `1 -> 2 -> 3 -> 4 -> nullptr`  

5. **Conteggio degli Elementi**:  
   Scrivi una funzione per contare il numero di nodi in una lista collegata.  
   **Input**: `1 -> 2 -> 3 -> nullptr`  
   **Output**: `3`  

6. **Verifica Presenza di un Elemento**:  
   Scrivi una funzione per verificare se un valore è presente in una lista collegata.  
   **Input**: `1 -> 2 -> 3 -> nullptr`, valore da cercare: `2`  
   **Output**: `true`  

---

#### **2.9 Vantaggi delle Liste concatenate**
1. **Dimensioni Dinamiche**: A differenza degli array, le liste concatenate non hanno una dimensione fissa. Possono crescere o ridursi durante l’esecuzione del programma.  
2. **Inserimenti/Cancellazioni Efficienti**: L’inserimento o la cancellazione di un nodo richiede solo la modifica dei puntatori, senza dover spostare gli altri elementi (come negli array).  
3. **Uso Efficiente della Memoria**: La memoria viene allocata dinamicamente solo quando necessario, riducendo gli sprechi.

---

#### **2.10 Svantaggi delle Liste concatenate**
1. **Accesso Casuale Lento**: Per accedere a un elemento in una posizione specifica, è necessario attraversare la lista dall’inizio, con una complessità O(n).  
2. **Overhead di Memoria**: Ogni nodo richiede memoria aggiuntiva per memorizzare il puntatore.  
3. **Complessità Implementativa**: La gestione dei puntatori può essere più complessa rispetto agli array, soprattutto per i principianti.

---

#### **2.11 Confronto tra Liste concatenate e Array**
| **Caratteristica**       | **Lista Collegata**                  | **Array**                     |  
|--------------------------|--------------------------------------|-------------------------------|  
| **Dimensione**           | Dinamica                            | Fissa                         |  
| **Inserimento/Cancellazione** | O(1) in testa/coda, O(n) in mezzo   | O(n) (spostamento elementi)   |  
| **Accesso Casuale**      | O(n)                                | O(1)                          |  
| **Uso Memoria**          | Overhead per i puntatori             | Contiguo, nessun overhead     |  

