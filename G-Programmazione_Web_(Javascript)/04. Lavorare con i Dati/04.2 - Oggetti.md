### **Oggetti**

In JavaScript, gli **oggetti** sono strutture fondamentali per rappresentare collezioni di dati complessi e modellare entità reali. Gli oggetti consentono di organizzare i dati in una serie di proprietà, costituite da coppie chiave-valore, dove le chiavi sono stringhe o simboli e i valori possono essere di qualsiasi tipo.

#### Creazione di un Oggetto

Esistono diversi modi per creare oggetti in JavaScript. Ecco alcuni dei più comuni:

1. **Notazione Letterale**:
   È il metodo più semplice e leggibile per creare un oggetto.
   ```javascript
   const persona = {
     nome: "Mario",
     cognome: "Rossi",
     età: 30
   };
   ```

2. **Costruttore `Object`**:
   Un altro metodo è utilizzare il costruttore `Object`.
   ```javascript
   const persona = new Object();
   persona.nome = "Mario";
   persona.cognome = "Rossi";
   persona.età = 30;
   ```

3. **Funzione Costruttrice**:
   Le funzioni costruttrici vengono utilizzate per creare più istanze di oggetti simili.
   ```javascript
   function Persona(nome, cognome, età) {
     this.nome = nome;
     this.cognome = cognome;
     this.età = età;
   }

   const persona1 = new Persona("Mario", "Rossi", 30);
   const persona2 = new Persona("Luigi", "Verdi", 25);
   ```

4. **Classi (ES6)**:
   A partire da ES6, JavaScript introduce la sintassi delle classi, rendendo più semplice la creazione di oggetti con funzioni costruttrici.
   ```javascript
   class Persona {
     constructor(nome, cognome, età) {
       this.nome = nome;
       this.cognome = cognome;
       this.età = età;
     }

     saluta() {
       return `Ciao, mi chiamo ${this.nome} ${this.cognome}`;
     }
   }

   const persona1 = new Persona("Mario", "Rossi", 30);
   console.log(persona1.saluta()); // Output: "Ciao, mi chiamo Mario Rossi"
   ```

#### Proprietà e Metodi

Ogni oggetto può avere **proprietà**, che contengono dati, e **metodi**, che sono funzioni all'interno dell'oggetto.

**Esempio:**
```javascript
const auto = {
  marca: "Fiat",
  modello: "Panda",
  anno: 2018,
  avvia: function() {
    console.log("L'auto è in moto.");
  }
};

console.log(auto.marca);  // Output: "Fiat"
auto.avvia();             // Output: "L'auto è in moto."
```

##### Accesso alle Proprietà
È possibile accedere alle proprietà di un oggetto tramite notazione con punto o con parentesi quadre:
```javascript
console.log(auto.marca);        // Notazione con punto
console.log(auto["modello"]);   // Notazione con parentesi quadre
```

##### Aggiungere, Modificare e Rimuovere Proprietà

- **Aggiungere o Modificare**:
  ```javascript
  auto.colore = "rosso";    // Aggiunge una nuova proprietà "colore"
  auto.anno = 2020;         // Modifica la proprietà "anno"
  ```

- **Rimuovere**:
  ```javascript
  delete auto.colore;       // Rimuove la proprietà "colore"
  ```

#### Metodi Utili per Gli Oggetti

JavaScript offre diversi metodi per lavorare con gli oggetti:

- **`Object.keys(obj)`**: restituisce un array contenente tutte le chiavi dell’oggetto `obj`.
  ```javascript
  console.log(Object.keys(auto)); // Output: ["marca", "modello", "anno"]
  ```

- **`Object.values(obj)`**: restituisce un array contenente tutti i valori delle proprietà dell’oggetto `obj`.
  ```javascript
  console.log(Object.values(auto)); // Output: ["Fiat", "Panda", 2018]
  ```

- **`Object.entries(obj)`**: restituisce un array di coppie [chiave, valore].
  ```javascript
  console.log(Object.entries(auto)); 
  // Output: [["marca", "Fiat"], ["modello", "Panda"], ["anno", 2018]]
  ```

#### Proprietà Getter e Setter

I **getter** e i **setter** sono metodi speciali che permettono di definire comportamento personalizzato quando si accede o si modifica una proprietà dell'oggetto.

- **Getter**: funzioni che vengono chiamate quando si legge una proprietà. Si definiscono con la parola chiave `get`.
- **Setter**: funzioni che vengono chiamate quando si assegna un valore a una proprietà. Si definiscono con la parola chiave `set`.

**Esempio base:**
```javascript
const persona = {
  nome: "Mario",
  cognome: "Rossi",
  
  // Getter
  get nomeCompleto() {
    return `${this.nome} ${this.cognome}`;
  },
  
  // Setter
  set nomeCompleto(valore) {
    const parti = valore.split(' ');
    this.nome = parti[0];
    this.cognome = parti[1];
  }
};

console.log(persona.nomeCompleto);  // Output: "Mario Rossi"
persona.nomeCompleto = "Luca Verdi";
console.log(persona.nome);         // Output: "Luca"
console.log(persona.cognome);      // Output: "Verdi"
```

**Vantaggi dei getter e setter:**
- Permettono di eseguire validazioni quando si assegnano valori
- Consentono di calcolare proprietà dinamiche
- Supportano l'incapsulamento (nascondere i dettagli implementativi)

**Esempio con validazione:**
```javascript
const studente = {
  _età: 20,  // La convenzione dell'underscore indica una proprietà "privata"
  
  get età() {
    return this._età;
  },
  
  set età(valore) {
    if (valore < 0) {
      console.error("L'età non può essere negativa");
      return;
    }
    if (valore > 120) {
      console.error("Età non valida");
      return;
    }
    this._età = valore;
  }
};

studente.età = 25;     // Funziona
console.log(studente.età);  // Output: 25

studente.età = -10;    // Output: "L'età non può essere negativa"
console.log(studente.età);  // Output: 25 (valore non modificato)
```

#### Destrutturazione di Oggetti

La **destrutturazione** è una sintassi che consente di estrarre dati da oggetti (o array) in variabili separate in modo conciso.

**Sintassi base:**
```javascript
const persona = {
  nome: "Giulia",
  cognome: "Bianchi", 
  età: 28
};

// Destrutturazione
const { nome, età } = persona;

console.log(nome);  // Output: "Giulia"
console.log(età);   // Output: 28
```

**Assegnazione con nomi di variabili diversi:**
```javascript
const { nome: firstName, cognome: lastName } = persona;
console.log(firstName);  // Output: "Giulia"
console.log(lastName);   // Output: "Bianchi"
```

**Valori predefiniti:**
```javascript
const utente = { nome: "Marco", ruolo: "Editor" };
const { nome, ruolo, id = "utente-123" } = utente;

console.log(id);  // Output: "utente-123" (valore predefinito)
```

**Destrutturazione di oggetti annidati:**
```javascript
const dipendente = {
  id: 1001,
  nome: "Sara",
  indirizzo: {
    via: "Via Roma 123",
    città: "Milano",
    cap: "20100"
  }
};

const { nome, indirizzo: { città } } = dipendente;
console.log(nome);   // Output: "Sara"
console.log(città);  // Output: "Milano"
```

**Destrutturazione nei parametri di funzione:**
```javascript
function mostraDati({ nome, età = 'non specificata' }) {
  console.log(`Nome: ${nome}, Età: ${età}`);
}

mostraDati({ nome: "Paolo", età: 35 });  // Output: "Nome: Paolo, Età: 35"
mostraDati({ nome: "Lucia" });           // Output: "Nome: Lucia, Età: non specificata"
```

#### Oggetti come Mappe (Dizionari)

Gli oggetti JavaScript possono essere utilizzati come **mappe** (o dizionari), ovvero collezioni di coppie chiave-valore dove ogni chiave è unica.

**Esempio di base:**
```javascript
const dizionarioUtenti = {
  "user123": { nome: "Alice", ruolo: "Admin" },
  "user456": { nome: "Bob", ruolo: "Editor" },
  "user789": { nome: "Carlo", ruolo: "Visitatore" }
};

// Accesso ai dati usando la chiave
console.log(dizionarioUtenti["user456"].nome);  // Output: "Bob"

// Aggiunta di un nuovo elemento
dizionarioUtenti["user101"] = { nome: "Diana", ruolo: "Editor" };

// Verifica se una chiave esiste
if ("user789" in dizionarioUtenti) {
  console.log("L'utente esiste");
}
```

**Esempio pratico - Contatore di occorrenze:**
```javascript
function contaParole(testo) {
  const parole = testo.toLowerCase().split(/\s+/);
  const conteggio = {};
  
  for (const parola of parole) {
    if (parola in conteggio) {
      conteggio[parola]++;
    } else {
      conteggio[parola] = 1;
    }
  }
  
  return conteggio;
}

const testo = "il gatto nero e il gatto bianco sono gatti";
const risultato = contaParole(testo);
console.log(risultato);
// Output: { "il": 2, "gatto": 2, "nero": 1, "e": 1, "bianco": 1, "sono": 1, "gatti": 1 }
```

**Nota:** Per casi d'uso più avanzati, JavaScript offre la classe `Map`, che supporta chiavi di qualsiasi tipo (non solo stringhe) e mantiene l'ordine di inserimento.

```javascript
const utentiMap = new Map();
utentiMap.set("user123", { nome: "Alice" });
utentiMap.set(42, { nome: "Utente speciale" }); // Chiave numerica
```

#### Serializzazione e Deserializzazione

La **serializzazione** è il processo di conversione di un oggetto JavaScript in una stringa. La **deserializzazione** è il processo inverso di conversione di una stringa in un oggetto JavaScript.

**JSON (JavaScript Object Notation)** è il formato più comune per la serializzazione in JavaScript.

**Serializzazione con `JSON.stringify()`:**
```javascript
const prodotto = {
  id: "p12345",
  nome: "Monitor 27 pollici",
  prezzo: 299.99,
  disponibile: true,
  caratteristiche: ["4K", "HDR", "IPS"]
};

// Conversione dell'oggetto in stringa JSON
const jsonString = JSON.stringify(prodotto);
console.log(jsonString);
// Output: {"id":"p12345","nome":"Monitor 27 pollici","prezzo":299.99,"disponibile":true,"caratteristiche":["4K","HDR","IPS"]}

// Serializzazione con formattazione (indentazione di 2 spazi)
const jsonFormattato = JSON.stringify(prodotto, null, 2);
console.log(jsonFormattato);
/*
{
  "id": "p12345",
  "nome": "Monitor 27 pollici",
  "prezzo": 299.99,
  "disponibile": true,
  "caratteristiche": [
    "4K",
    "HDR",
    "IPS"
  ]
}
*/
```

**Deserializzazione con `JSON.parse()`:**
```javascript
const jsonString = '{"id":"p12345","nome":"Monitor 27 pollici","prezzo":299.99}';
const prodotto = JSON.parse(jsonString);

console.log(prodotto.nome);  // Output: "Monitor 27 pollici"
console.log(prodotto.prezzo); // Output: 299.99
```

**Casi d'uso comuni:**
- Memorizzare dati in localStorage o sessionStorage
- Inviare e ricevere dati da API web
- Salvare configurazioni o stato dell'applicazione

**Limitazioni di JSON:**
- Funzioni non possono essere serializzate
- Le date vengono convertite in stringhe
- Non supporta reference circolari

```javascript
// Esempio di gestione date
const evento = {
  titolo: "Conferenza",
  data: new Date('2023-11-15T10:00:00')
};

const json = JSON.stringify(evento);
console.log(json); // La data è stata convertita in stringa

const eventoRecuperato = JSON.parse(json);
console.log(eventoRecuperato.data); // È una stringa, non un oggetto Date

// Conversione della stringa in oggetto Date
eventoRecuperato.data = new Date(eventoRecuperato.data);
```

#### Method Chaining (Concatenazione di Metodi)

Il **method chaining** è una tecnica di programmazione che consente di chiamare più metodi in sequenza sulla stessa istanza di un oggetto. Per consentirlo, ogni metodo deve restituire l'oggetto stesso (`this`).

**Esempio base:**
```javascript
class Carrello {
  constructor() {
    this.prodotti = [];
    this.totale = 0;
  }
  
  aggiungiProdotto(nome, prezzo) {
    this.prodotti.push({ nome, prezzo });
    this.totale += prezzo;
    return this; // Importante: ritorna l'istanza per permettere il chaining
  }
  
  applicaSconto(percentuale) {
    this.totale -= (this.totale * percentuale / 100);
    return this;
  }
  
  mostraTotale() {
    console.log(`Totale: €${this.totale.toFixed(2)}`);
    return this;
  }
}

// Utilizzo del method chaining
const ordine = new Carrello();
ordine
  .aggiungiProdotto("Libro", 15.99)
  .aggiungiProdotto("Penna", 2.50)
  .applicaSconto(10)
  .mostraTotale() // Output: "Totale: €16.64"
  .aggiungiProdotto("Quaderno", 4.99)
  .mostraTotale(); // Output: "Totale: €21.63"
```

**Vantaggi del method chaining:**
- Codice più conciso e leggibile
- Riduce la necessità di variabili temporanee
- Semplifica operazioni consecutive sullo stesso oggetto

**Esempio reale con manipolazione stringhe:**
```javascript
class StringProcessor {
  constructor(stringa) {
    this.stringa = stringa;
  }
  
  toUpperCase() {
    this.stringa = this.stringa.toUpperCase();
    return this;
  }
  
  trim() {
    this.stringa = this.stringa.trim();
    return this;
  }
  
  replace(searchValue, replaceValue) {
    this.stringa = this.stringa.replace(searchValue, replaceValue);
    return this;
  }
  
  get() {
    return this.stringa;
  }
}

const risultato = new StringProcessor("  ciao mondo  ")
  .trim()
  .toUpperCase()
  .replace("MONDO", "JAVASCRIPT")
  .get();

console.log(risultato); // Output: "CIAO JAVASCRIPT"
```

**Method chaining con array nativi:**
JavaScript supporta il method chaining su diversi metodi nativi degli array:

```javascript
const numeri = [1, 2, 3, 4, 5, 6];
const risultato = numeri
  .filter(n => n % 2 === 0)  // Filtra i numeri pari: [2, 4, 6]
  .map(n => n * 2)           // Raddoppia ogni valore: [4, 8, 12]  
  .reduce((sum, n) => sum + n, 0); // Somma tutti i valori

console.log(risultato); // Output: 24
```

#### Passaggio per Riferimento

Gli oggetti in JavaScript sono **tipi di riferimento**, il che significa che se si assegna un oggetto a un’altra variabile, entrambe le variabili puntano allo stesso oggetto in memoria. Di conseguenza, una modifica apportata tramite una variabile influenzerà anche l’altra.

**Esempio:**
```javascript
const personaA = { nome: "Alice", età: 25 };
const personaB = personaA;  // personaB punta allo stesso oggetto di personaA

personaB.nome = "Clara";
console.log(personaA.nome); // Output: "Clara"
```

#### Esercizio Pratico

1. Crea un oggetto `libro` con proprietà `titolo`, `autore` e `anno`.
2. Aggiungi un metodo `descrizione()` che restituisca una stringa contenente tutte le informazioni sul libro.
3. Modifica il valore della proprietà `anno` e verifica che il metodo `descrizione()` restituisca il valore aggiornato.

--- 
[INDICE](README.md)