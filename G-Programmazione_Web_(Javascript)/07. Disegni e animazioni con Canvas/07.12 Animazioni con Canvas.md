### **7.12 Animazioni con Canvas**

L'animazione è una delle caratteristiche più potenti di Canvas, permettendo di creare contenuti dinamici e interattivi. In questa sezione esploreremo le tecniche principali per animare elementi su Canvas.

---

### **Principi di base dell'animazione**

L'animazione su Canvas si basa su tre concetti fondamentali:

1. **Cancellazione**: Pulire il Canvas o parte di esso.
2. **Disegno**: Ridisegnare gli elementi aggiornati.
3. **Ripetizione**: Ripetere il ciclo a intervalli regolari.

---

### **Loop di animazione con `requestAnimationFrame`**

Il metodo `requestAnimationFrame` è lo standard attuale per creare animazioni fluide:

```javascript
function animate() {
    // 1. Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 2. Aggiorna le posizioni o proprietà
    x += velocityX;
    y += velocityY;
    
    // 3. Ridisegna gli elementi
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // 4. Richiedi il prossimo frame
    requestAnimationFrame(animate);
}

// Avvia l'animazione
animate();
```

Vantaggi di `requestAnimationFrame` rispetto a `setInterval`:
- Si sincronizza automaticamente con il refresh del monitor
- Si ferma quando la scheda non è attiva
- Ottimizza l'uso di CPU

---

### **Controllo del tempo e della velocità**

Per garantire animazioni coerenti indipendentemente dal frame rate:

```javascript
let lastTime = 0;

function animate(currentTime) {
    // Calcola il delta temporale
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    // Aggiorna in base al tempo trascorso
    x += velocityX * (deltaTime / 16.67); // 16.67ms = 60fps
    
    // Disegno e pulizia...
    
    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
```

---

### **Esempio: Pallina Rimbalzante**

Un esempio classico di animazione è una pallina che rimbalza sui bordi del canvas.

#### **HTML**
```html
<canvas id="animationCanvas" width="600" height="400" style="border: 1px solid black;"></canvas>
```

#### **JavaScript**
```javascript
const canvas = document.getElementById("animationCanvas");
const ctx = canvas.getContext("2d");

let ball = {
    x: 100,
    y: 100,
    radius: 20,
    dx: 5,
    dy: 3,
    color: "red"
};

function animate() {
    // Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Disegna la pallina
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    
    // Aggiorna la posizione
    ball.x += ball.dx;
    ball.y += ball.dy;
    
    // Controlla collisioni con i bordi
    if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx = -ball.dx;
    }
    
    if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
        ball.dy = -ball.dy;
    }
    
    requestAnimationFrame(animate);
}

animate();
```

---

### **Effetti di Easing**

Gli effetti di easing rendono le animazioni più naturali e piacevoli:

```javascript
function easeOutQuad(t) {
    return t * (2 - t);
}

function animateWithEasing() {
    let progress = 0;
    let startX = 100;
    let endX = 500;
    
    function step() {
        progress += 0.01;
        if (progress > 1) progress = 1;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Applica la funzione di easing
        const easedProgress = easeOutQuad(progress);
        const x = startX + (endX - startX) * easedProgress;
        
        ctx.beginPath();
        ctx.arc(x, 200, 30, 0, Math.PI * 2);
        ctx.fill();
        
        if (progress < 1) {
            requestAnimationFrame(step);
        }
    }
    
    requestAnimationFrame(step);
}
```

---

### **Animazioni sprite**

Per animazioni più complesse come personaggi di giochi:

```javascript
const spriteSheet = new Image();
spriteSheet.src = 'path/to/spritesheet.png';

let frameIndex = 0;
const frameWidth = 64;
const frameHeight = 64;
const totalFrames = 8;

function animateSprite() {
    // Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Calcola posizione frame nel foglio sprite
    const col = frameIndex % 4;
    const row = Math.floor(frameIndex / 4);
    
    // Disegna il frame corrente
    ctx.drawImage(
        spriteSheet,
        col * frameWidth, row * frameHeight, // Posizione nel foglio
        frameWidth, frameHeight, // Dimensioni nel foglio
        100, 100, // Posizione nel canvas
        frameWidth, frameHeight // Dimensioni nel canvas
    );
    
    // Avanza al prossimo frame
    frameIndex = (frameIndex + 1) % totalFrames;
    
    setTimeout(() => {
        requestAnimationFrame(animateSprite);
    }, 100); // Cambia frame ogni 100ms
}

spriteSheet.onload = animateSprite;
```

---

### **Conclusioni**

L'animazione è una delle funzionalità più potenti di Canvas, permettendo di creare esperienze interattive dinamiche. Utilizzando `requestAnimationFrame` e tecniche appropriate di gestione del tempo, è possibile creare animazioni fluide e performanti. Nei prossimi capitoli esploreremo l'ottimizzazione delle prestazioni per garantire animazioni fluide anche in scenari complessi.

---
[Gestione degli eventi - Gestione del touch](<07.11 Gestione degli eventi - Gestione del touch.md>) | [Indice](<README.md>) | [Ottimizzazione delle prestazioni](<07.13 Ottimizzazione delle prestazioni.md>)
