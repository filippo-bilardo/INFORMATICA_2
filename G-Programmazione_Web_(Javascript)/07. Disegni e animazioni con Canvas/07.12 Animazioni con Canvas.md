### **7.12 Animazioni con Canvas**

L'animazione è una delle caratteristiche più potenti di Canvas, permettendo di creare contenuti dinamici e interattivi. In questa sezione esploreremo le tecniche principali per animare elementi su Canvas.

---

### **Principi di base dell'animazione**

L'animazione su Canvas si basa su tre concetti fondamentali:

1. **Cancellazione**: Pulire il Canvas o parte di esso.
2. **Disegno**: Ridisegnare gli elementi aggiornati.
3. **Ripetizione**: Ripetere il ciclo a intervalli regolari.

---

### **Loop di animazione con `requestAnimationFrame`**

Il metodo `requestAnimationFrame` è lo standard attuale per creare animazioni fluide:

```javascript
function animate() {
    // 1. Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 2. Aggiorna le posizioni o proprietà
    x += velocityX;
    y += velocityY;
    
    // 3. Ridisegna gli elementi
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // 4. Richiedi il prossimo frame
    requestAnimationFrame(animate);
}

// Avvia l'animazione
animate();
```

Vantaggi di `requestAnimationFrame` rispetto a `setInterval`:
- Si sincronizza automaticamente con il refresh del monitor
- Si ferma quando la scheda non è attiva
- Ottimizza l'uso di CPU

---

### **Controllo del tempo e della velocità**

Per garantire animazioni coerenti indipendentemente dal frame rate:

```javascript
let lastTime = 0;

function animate(currentTime) {
    // Calcola il delta temporale
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    // Aggiorna in base al tempo trascorso
    x += velocityX * (deltaTime / 16.67); // 16.67ms = 60fps
    
    // Disegno e pulizia...
    
    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
```

---

### **Esempio: Pallina Rimbalzante**

Un esempio classico di animazione è una pallina che rimbalza sui bordi del canvas.

#### **HTML**
```html
<canvas id="animationCanvas" width="600" height="400" style="border: 1px solid black;"></canvas>
```

#### **JavaScript**
```javascript
const canvas = document.getElementById("animationCanvas");
const ctx = canvas.getContext("2d");

let ball = {
    x: 100,
    y: 100,
    radius: 20,
    dx: 5,
    dy: 3,
    color: "red"
};

function animate() {
    // Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Disegna la pallina
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    
    // Aggiorna la posizione
    ball.x += ball.dx;
    ball.y += ball.dy;
    
    // Controlla collisioni con i bordi
    if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx = -ball.dx;
    }
    
    if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
        ball.dy = -ball.dy;
    }
    
    requestAnimationFrame(animate);
}

animate();
```

---

### **Effetti di Easing**

Gli effetti di easing rendono le animazioni più naturali e piacevoli:

```javascript
function easeOutQuad(t) {
    return t * (2 - t);
}

function animateWithEasing() {
    let progress = 0;
    let startX = 100;
    let endX = 500;
    
    function step() {
        progress += 0.01;
        if (progress > 1) progress = 1;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Applica la funzione di easing
        const easedProgress = easeOutQuad(progress);
        const x = startX + (endX - startX) * easedProgress;
        
        ctx.beginPath();
        ctx.arc(x, 200, 30, 0, Math.PI * 2);
        ctx.fill();
        
        if (progress < 1) {
            requestAnimationFrame(step);
        }
    }
    
    requestAnimationFrame(step);
}
```

---

### **Animazioni sprite**

Per animazioni più complesse come personaggi di giochi:

```javascript
const spriteSheet = new Image();
spriteSheet.src = 'path/to/spritesheet.png';

let frameIndex = 0;
const frameWidth = 64;
const frameHeight = 64;
const totalFrames = 8;

function animateSprite() {
    // Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Calcola posizione frame nel foglio sprite
    const col = frameIndex % 4;
    const row = Math.floor(frameIndex / 4);
    
    // Disegna il frame corrente
    ctx.drawImage(
        spriteSheet,
        col * frameWidth, row * frameHeight, // Posizione nel foglio
        frameWidth, frameHeight, // Dimensioni nel foglio
        100, 100, // Posizione nel canvas
        frameWidth, frameHeight // Dimensioni nel canvas
    );
    
    // Avanza al prossimo frame
    frameIndex = (frameIndex + 1) % totalFrames;
    
    setTimeout(() => {
        requestAnimationFrame(animateSprite);
    }, 100); // Cambia frame ogni 100ms
}

spriteSheet.onload = animateSprite;
```

---

### **Esempio avanzato: Sistema di particelle interattivo**

Un sistema di particelle è un ottimo esempio di animazione complessa che combina movimento, fisica e interazione con l'utente.

#### **HTML**
```html
<canvas id="particleCanvas" width="800" height="600" style="border: 1px solid black;"></canvas>
```

#### **JavaScript**
```javascript
const canvas = document.getElementById("particleCanvas");
const ctx = canvas.getContext("2d");
const particles = [];
const mouse = { x: null, y: null, radius: 150 };

// Configura gli eventi mouse/touch
canvas.addEventListener('mousemove', (e) => {
    mouse.x = e.x;
    mouse.y = e.y;
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    mouse.x = e.touches[0].clientX;
    mouse.y = e.touches[0].clientY;
}, { passive: false });

// Quando il mouse esce dal canvas
canvas.addEventListener('mouseleave', () => {
    mouse.x = null;
    mouse.y = null;
});

// Classe Particella
class Particle {
    constructor() {
        // Posizione iniziale casuale
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        
        // Dimensione casuale
        this.size = Math.random() * 5 + 2;
        
        // Velocità casuale
        this.speedX = Math.random() * 3 - 1.5;
        this.speedY = Math.random() * 3 - 1.5;
        
        // Colore casuale
        this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
    }
    
    // Aggiorna posizione
    update() {
        // Movimento base
        this.x += this.speedX;
        this.y += this.speedY;
        
        // Rimbalza dai bordi
        if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
        if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
        
        // Interazione col mouse
        if (mouse.x !== null && mouse.y !== null) {
            const dx = mouse.x - this.x;
            const dy = mouse.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < mouse.radius) {
                // Calcola angolo tra particella e mouse
                const angle = Math.atan2(dy, dx);
                
                // Allontana la particella dal mouse
                const force = (mouse.radius - distance) / mouse.radius;
                
                this.speedX -= force * Math.cos(angle) * 0.5;
                this.speedY -= force * Math.sin(angle) * 0.5;
            }
        }
        
        // Limita la velocità
        this.speedX = Math.max(-3, Math.min(3, this.speedX));
        this.speedY = Math.max(-3, Math.min(3, this.speedY));
    }
    
    // Disegna la particella
    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
    }
}

// Inizializza le particelle
function init() {
    for (let i = 0; i < 100; i++) {
        particles.push(new Particle());
    }
}

// Loop di animazione principale
function animate() {
    // Pulisci il canvas con un effetto scia
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Aggiorna e disegna ogni particella
    for (let i = 0; i < particles.length; i++) {
        particles[i].update();
        particles[i].draw();
    }
    
    requestAnimationFrame(animate);
}

// Avvia l'animazione
init();
animate();
```

Questo esempio dimostra:
- Gestione di molteplici oggetti animati simultaneamente
- Interazione basata sulla fisica (repulsione dal mouse)
- Effetto scia usando la trasparenza
- Combinazione di eventi mouse/touch
- Utilizzo di classi per organizzare il codice

---

### **Conclusioni**

L'animazione è una delle funzionalità più potenti di Canvas, permettendo di creare esperienze interattive dinamiche. Utilizzando `requestAnimationFrame` e tecniche appropriate di gestione del tempo, è possibile creare animazioni fluide e performanti. Nei prossimi capitoli esploreremo l'ottimizzazione delle prestazioni per garantire animazioni fluide anche in scenari complessi.

---
[Gestione degli eventi - Gestione del touch](<07.11 Gestione degli eventi - Gestione del touch.md>) | [Indice](<README.md>) | [Ottimizzazione delle prestazioni](<07.13 Ottimizzazione delle prestazioni.md>)
