### **7.13 Ottimizzazione delle prestazioni**

Il Canvas offre potenti strumenti per creare grafiche dinamiche, ma in applicazioni complesse può causare problemi di prestazioni. Questo capitolo esplora tecniche per ottimizzare la velocità di rendering e migliorare l'esperienza utente.

---

### **Principi fondamentali per l'ottimizzazione**

1. **Minimizzare le operazioni di disegno**: ogni chiamata ai metodi di disegno ha un costo.
2. **Ridurre i cambiamenti di stato**: cambiare colori, stili e trasformazioni è costoso.
3. **Limitare la superficie di ridisegno**: aggiornare solo le parti necessarie del canvas.
4. **Utilizzare tecniche di caching**: pre-renderizzare elementi che cambiano raramente.

---

### **Monitoraggio delle prestazioni**

Prima di ottimizzare, è importante misurare:

```javascript
// Misura il tempo di esecuzione
const start = performance.now();
drawScene(); // La funzione che disegna sul canvas
const duration = performance.now() - start;
console.log(`Rendering: ${duration.toFixed(2)}ms`);

// Calcola FPS
let frameCount = 0;
let lastTime = performance.now();

function checkFPS() {
    const now = performance.now();
    frameCount++;
    
    if (now - lastTime >= 1000) {
        const fps = frameCount;
        console.log(`FPS: ${fps}`);
        frameCount = 0;
        lastTime = now;
    }
    
    requestAnimationFrame(checkFPS);
}
checkFPS();
```

---

### **Off-screen Canvas e Buffer**

Una delle tecniche più efficaci è il pre-rendering in un canvas invisibile:

```javascript
// Crea un canvas off-screen
const offscreenCanvas = document.createElement('canvas');
offscreenCanvas.width = mainCanvas.width;
offscreenCanvas.height = mainCanvas.height;
const offCtx = offscreenCanvas.getContext('2d');

// Disegna elementi statici una sola volta
function drawStaticElements() {
    // Disegna sfondo, oggetti statici, ecc.
    offCtx.fillStyle = 'skyblue';
    offCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
    // Disegna altri elementi...
}

// Nel loop di animazione, copia il buffer e aggiungi gli elementi dinamici
function animate() {
    ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    
    // Copia il buffer pre-renderizzato
    ctx.drawImage(offscreenCanvas, 0, 0);
    
    // Disegna solo gli elementi dinamici
    drawDynamicElements();
    
    requestAnimationFrame(animate);
}

// Inizializzazione
drawStaticElements(); // Una volta sola
animate(); // Loop
```

---

### **Ottimizzazione degli stati di Canvas**

Raggruppa le operazioni di disegno per tipo per minimizzare i cambiamenti di stato:

```javascript
// Inefficiente: continui cambi di stato
function inefficientDraw() {
    for (const circle of circles) {
        ctx.fillStyle = circle.color;
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Ottimizzato: raggruppa per colore
function optimizedDraw() {
    // Raggruppa cerchi per colore
    const circlesByColor = {};
    for (const circle of circles) {
        if (!circlesByColor[circle.color]) {
            circlesByColor[circle.color] = [];
        }
        circlesByColor[circle.color].push(circle);
    }
    
    // Disegna un colore alla volta
    for (const color in circlesByColor) {
        ctx.fillStyle = color;
        ctx.beginPath();
        for (const circle of circlesByColor[color]) {
            ctx.moveTo(circle.x, circle.y);
            ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
        }
        ctx.fill();
    }
}
```

---

### **Ottimizzare le trasformazioni**

Le operazioni di trasformazione sono costose; usa la matematica quando possibile:

```javascript
// Meno efficiente: trasformazione per ogni elemento
function lessEfficient() {
    for (const obj of objects) {
        ctx.save();
        ctx.translate(obj.x, obj.y);
        ctx.rotate(obj.angle);
        ctx.drawImage(image, -image.width/2, -image.height/2);
        ctx.restore();
    }
}

// Più efficiente: calcolo manuale
function moreEfficient() {
    for (const obj of objects) {
        // Calcola la rotazione manualmente
        const cos = Math.cos(obj.angle);
        const sin = Math.sin(obj.angle);
        
        // Applica transformazione ai vertici
        const x1 = -image.width/2;
        const y1 = -image.height/2;
        const x2 = image.width/2;
        const y2 = image.height/2;
        
        // Trasforma e disegna l'immagine direttamente
        ctx.setTransform(
            cos, sin,
            -sin, cos,
            obj.x, obj.y
        );
        ctx.drawImage(image, x1, y1, image.width, image.height);
    }
    // Ripristina la trasformazione alla fine
    ctx.setTransform(1, 0, 0, 1, 0, 0);
}
```

---

### **Limitare l'area di ridisegno**

Per applicazioni complesse, ridisegnare solo le aree modificate:

```javascript
function redrawRegion(x, y, width, height) {
    // Pulisci solo l'area necessaria
    ctx.clearRect(x, y, width, height);
    
    // Ridisegna solo gli oggetti in quest'area
    for (const obj of objects) {
        if (objectIntersectsRegion(obj, x, y, width, height)) {
            drawObject(obj);
        }
    }
}

function objectIntersectsRegion(obj, x, y, width, height) {
    // Logica di intersezione tra oggetto e regione
    return (
        obj.x + obj.width > x &&
        obj.x < x + width &&
        obj.y + obj.height > y &&
        obj.y < y + height
    );
}
```

---

### **Utilizzo di Web Workers**

Per calcoli intensivi, sposta il lavoro in un thread separato:

```javascript
// Nel main thread
const worker = new Worker('canvas-worker.js');

worker.onmessage = function(e) {
    // Ricevi i risultati dal worker
    const { positions } = e.data;
    
    // Usa i dati per aggiornare il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const pos of positions) {
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, pos.radius, 0, Math.PI * 2);
        ctx.fill();
    }
};

// Invia dati al worker
worker.postMessage({
    command: 'calculate',
    params: { /* parametri */ }
});

// Nel file canvas-worker.js
onmessage = function(e) {
    if (e.data.command === 'calculate') {
        // Esegui calcoli pesanti
        const positions = calculateParticlePositions(e.data.params);
        
        // Restituisci i risultati
        postMessage({ positions });
    }
};
```

---

### **Uso di requestAnimationFrame in modo efficiente**

```javascript
let animationId;

function startAnimation() {
    let isRunning = true;
    
    function loop() {
        if (!isRunning) return;
        
        // Disegna solo se la finestra è visibile
        if (document.visibilityState === 'visible') {
            updateAndDraw();
        }
        
        animationId = requestAnimationFrame(loop);
    }
    
    animationId = requestAnimationFrame(loop);
    
    // Ferma l'animazione quando la scheda non è visibile
    document.addEventListener('visibilitychange', () => {
        isRunning = document.visibilityState === 'visible';
        if (isRunning && !animationId) {
            animationId = requestAnimationFrame(loop);
        }
    });
}
```

---

### **Conclusioni**

L'ottimizzazione delle prestazioni di Canvas richiede un approccio sistematico: misura prima di ottimizzare, identifica i colli di bottiglia e applica le tecniche più adatte al tuo caso specifico. Utilizzando buffer off-screen, minimizzando i cambi di stato e sfruttando tecnologie come Web Workers, puoi ottenere animazioni fluide anche in applicazioni Canvas complesse.

---
[Animazioni con Canvas](<07.12 Animazioni con Canvas.md>) | [Indice](<README.md>)
