<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animazioni con Canvas</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 5px;
        }
        h1, h2 {
            color: #333;
        }
        h1 {
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        canvas {
            border: 1px solid #ddd;
            margin: 15px 0;
            background-color: white;
            display: block;
        }
        .section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .controls {
            margin: 15px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 5px;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        input[type="range"] {
            width: 180px;
            vertical-align: middle;
        }
        .code-container {
            background-color: #f8f8f8;
            border-left: 4px solid #4CAF50;
            padding: 10px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
        }
        .note {
            background-color: #e7f3fe;
            border-left: 4px solid #2196F3;
            padding: 10px;
            margin: 15px 0;
        }
        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Animazioni con Canvas</h1>
        <p>
            Canvas è uno strumento eccellente per creare animazioni. In questa guida vedremo come creare
            animazioni fluide utilizzando la funzione <code>requestAnimationFrame</code>, che è il metodo
            più efficiente per creare animazioni nel browser.
        </p>

        <div class="section">
            <h2>1. Animazione di base</h2>
            <p>Ecco un esempio di animazione di base con un oggetto in movimento:</p>
            
            <canvas id="basicAnimationCanvas" width="500" height="300"></canvas>
            
            <div class="controls">
                <button id="startBasicAnimation">Avvia</button>
                <button id="stopBasicAnimation">Ferma</button>
            </div>
            
            <div class="code-container">
                <pre><code>// Variabili per l'animazione
let animationId;
let x = 50;
let y = 150;
let dx = 2;
let radius = 20;

// Funzione di animazione
function animate() {
    // Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Disegna il cerchio
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = 'blue';
    ctx.fill();
    
    // Aggiorna la posizione
    x += dx;
    
    // Inverti la direzione quando tocca i bordi
    if (x + radius > canvas.width || x - radius < 0) {
        dx = -dx;
    }
    
    // Richiedi il prossimo frame
    animationId = requestAnimationFrame(animate);
}

// Avvia l'animazione
animate();</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>2. Animazione con controllo della velocità</h2>
            <p>
                Puoi controllare la velocità dell'animazione utilizzando il tempo trascorso tra i frame:
            </p>
            
            <canvas id="speedControlCanvas" width="500" height="300"></canvas>
            
            <div class="controls">
                <label for="speedControl">Velocità:</label>
                <input type="range" id="speedControl" min="0" max="10" value="5" step="0.1">
                <span id="speedValue">5</span>
                <button id="startSpeedAnimation">Avvia</button>
                <button id="stopSpeedAnimation">Ferma</button>
            </div>
            
            <div class="code-container">
                <pre><code>// Variabili per l'animazione
let lastTime = 0;
let speed = 100; // pixel al secondo

function animate(currentTime) {
    // Calcola il tempo trascorso in secondi
    if (!lastTime) lastTime = currentTime;
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    
    // Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Aggiorna la posizione in base al tempo trascorso
    x += speed * deltaTime;
    
    // Disegna l'oggetto
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Richiedi il prossimo frame
    requestAnimationFrame(animate);
}</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>3. Animazione di più oggetti</h2>
            <p>
                Puoi animare più oggetti contemporaneamente gestendoli in un array:
            </p>
            
            <canvas id="multipleObjectsCanvas" width="500" height="300"></canvas>
            
            <div class="controls">
                <button id="addBall">Aggiungi Pallina</button>
                <button id="startMultipleAnimation">Avvia</button>
                <button id="stopMultipleAnimation">Ferma</button>
                <button id="clearBalls">Rimuovi Tutte</button>
            </div>
            
            <div class="code-container">
                <pre><code>// Array di oggetti
const balls = [];

// Funzione per creare un nuovo oggetto
function createBall() {
    return {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        radius: 5 + Math.random() * 15,
        dx: Math.random() * 4 - 2,
        dy: Math.random() * 4 - 2,
        color: `rgb(${Math.floor(Math.random() * 255)}, 
                ${Math.floor(Math.random() * 255)}, 
                ${Math.floor(Math.random() * 255)})`
    };
}

// Funzione di animazione
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Aggiorna e disegna ogni oggetto
    for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        
        // Aggiorna la posizione
        ball.x += ball.dx;
        ball.y += ball.dy;
        
        // Controlla le collisioni con i bordi
        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
            ball.dx = -ball.dx;
        }
        if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
            ball.dy = -ball.dy;
        }
        
        // Disegna la pallina
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
    }
    
    requestAnimationFrame(animate);
}</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>4. Animazione con fisica semplice</h2>
            <p>
                Aggiungiamo effetti fisici come gravità e rimbalzo:
            </p>
            
            <canvas id="physicsCanvas" width="500" height="300"></canvas>
            
            <div class="controls">
                <button id="startPhysicsAnimation">Avvia</button>
                <button id="stopPhysicsAnimation">Ferma</button>
                <button id="addPhysicsBall">Aggiungi Pallina</button>
            </div>
            
            <div class="code-container">
                <pre><code>// Costanti fisiche
const gravity = 0.2;
const friction = 0.99;

// Funzione di animazione con fisica
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        
        // Applica la gravità
        ball.dy += gravity;
        
        // Aggiorna la posizione
        ball.x += ball.dx;
        ball.y += ball.dy;
        
        // Controlla le collisioni con i bordi
        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
            ball.dx = -ball.dx * friction;
        }
        
        // Rimbalzo sul fondo con perdita di energia
        if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.dy = -ball.dy * friction;
        }
        
        // Disegna la pallina
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
    }
    
    requestAnimationFrame(animate);
}</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>5. Animazione con easing</h2>
            <p>
                Le funzioni di easing rendono le animazioni più naturali e piacevoli:
            </p>
            
            <canvas id="easingCanvas" width="500" height="300"></canvas>
            
            <div class="controls">
                <button id="linearEasing">Lineare</button>
                <button id="easeOutEasing">Ease Out</button>
                <button id="easeInOutEasing">Ease In-Out</button>
                <button id="bounceEasing">Rimbalzo</button>
            </div>
            
            <div class="code-container">
                <pre><code>// Funzioni di easing
const easingFunctions = {
    // Movimento lineare
    linear: t => t,
    
    // Rallenta alla fine
    easeOut: t => 1 - Math.pow(1 - t, 3),
    
    // Rallenta all'inizio e alla fine
    easeInOut: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
    
    // Effetto rimbalzo
    bounce: t => {
        const n1 = 7.5625;
        const d1 = 2.75;
        
        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }
};

// Animazione con easing
function animateWithEasing(easingFunction) {
    let startTime = null;
    const duration = 2000; // 2 secondi
    const startX = 50;
    const endX = canvas.width - 50;
    
    function step(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Applica la funzione di easing
        const easedProgress = easingFunction(progress);
        
        // Calcola la posizione corrente
        const x = startX + (endX - startX) * easedProgress;
        
        // Disegna
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.arc(x, canvas.height / 2, 20, 0, Math.PI * 2);
        ctx.fill();
        
        if (progress < 1) {
            requestAnimationFrame(step);
        }
    }
    
    requestAnimationFrame(step);
}</code></pre>
            </div>
        </div>
    </div>

    <script>
        // 1. Animazione di base
        const basicAnimationCanvas = document.getElementById('basicAnimationCanvas');
        const basicAnimationCtx = basicAnimationCanvas.getContext('2d');
        let basicAnimationId;
        let basicX = 50;
        const basicY = 150;
        let basicDx = 2;
        const basicRadius = 20;
        
        function animateBasic() {
            basicAnimationCtx.clearRect(0, 0, basicAnimationCanvas.width, basicAnimationCanvas.height);
            
            // Disegna il cerchio
            basicAnimationCtx.beginPath();
            basicAnimationCtx.arc(basicX, basicY, basicRadius, 0, Math.PI * 2);
            basicAnimationCtx.fillStyle = 'blue';
            basicAnimationCtx.fill();
            
            // Aggiorna la posizione
            basicX += basicDx;
            
            // Inverti la direzione quando tocca i bordi
            if (basicX + basicRadius > basicAnimationCanvas.width || basicX - basicRadius < 0) {
                basicDx = -basicDx;
            }
            
            // Richiedi il prossimo frame
            basicAnimationId = requestAnimationFrame(animateBasic);
        }
        
        // Disegna il cerchio iniziale
        basicAnimationCtx.beginPath();
        basicAnimationCtx.arc(basicX, basicY, basicRadius, 0, Math.PI * 2);
        basicAnimationCtx.fillStyle = 'blue';
        basicAnimationCtx.fill();
        
        // Controlli per l'animazione di base
        document.getElementById('startBasicAnimation').addEventListener('click', function() {
            if (!basicAnimationId) {
                animateBasic();
            }
        });
        
        document.getElementById('stopBasicAnimation').addEventListener('click', function() {
            if (basicAnimationId) {
                cancelAnimationFrame(basicAnimationId);
                basicAnimationId = null;
            }
        });
        
        // 2. Animazione con controllo della velocità
        const speedControlCanvas = document.getElementById('speedControlCanvas');
        const speedControlCtx = speedControlCanvas.getContext('2d');
        let speedAnimationId;
        let speedX = 50;
        const speedY = 150;
        const speedRadius = 20;
        let speed = 100; // pixel al secondo
        let lastTime = 0;
        
        function animateSpeed(currentTime) {
            // Calcola il tempo trascorso in secondi
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            speedControlCtx.clearRect(0, 0, speedControlCanvas.width, speedControlCanvas.height);
            
            // Aggiorna la posizione in base al tempo trascorso
            speedX += speed * deltaTime;
            
            // Inverti la direzione quando tocca i bordi
            if (speedX + speedRadius > speedControlCanvas.width || speedX - speedRadius < 0) {
                speed = -speed;
            }
            
            // Disegna il cerchio
            speedControlCtx.beginPath();
            speedControlCtx.arc(speedX, speedY, speedRadius, 0, Math.PI * 2);
            speedControlCtx.fillStyle = 'red';
            speedControlCtx.fill();
            
            // Richiedi il prossimo frame
            speedAnimationId = requestAnimationFrame(animateSpeed);
        }
        
        // Disegna il cerchio iniziale
        speedControlCtx.beginPath();
        speedControlCtx.arc(speedX, speedY, speedRadius, 0, Math.PI * 2);
        speedControlCtx.fillStyle = 'red';
        speedControlCtx.fill();
        
        // Controlli per l'animazione con velocità
        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        
        speedControl.addEventListener('input', function() {
            const value = parseFloat(this.value);
            speedValue.textContent = value;
            speed = value * 50 * (speed < 0 ? -1 : 1); // Mantieni la direzione
        });
        
        document.getElementById('startSpeedAnimation').addEventListener('click', function() {
            if (!speedAnimationId) {
                lastTime = 0;
                animateSpeed(0);
            }
        });
        
        document.getElementById('stopSpeedAnimation').addEventListener('click', function() {
            if (speedAnimationId) {
                cancelAnimationFrame(speedAnimationId);
                speedAnimationId = null;
            }
        });
        
        // 3. Animazione di più oggetti
        const multipleObjectsCanvas = document.getElementById('multipleObjectsCanvas');
        const multipleObjectsCtx = multipleObjectsCanvas.getContext('2d');
        let multipleAnimationId;
        const balls = [];
        
        function createBall() {
            return {
                x: Math.random() * multipleObjectsCanvas.width,
                y: Math.random() * multipleObjectsCanvas.height,
                radius: 5 + Math.random() * 15,
                dx: Math.random() * 4 - 2,
                dy: Math.random() * 4 - 2,
                color: `rgb(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)})`
            };
        }
        
        function animateMultiple() {
            multipleObjectsCtx.clearRect(0, 0, multipleObjectsCanvas.width, multipleObjectsCanvas.height);
            
            // Aggiorna e disegna ogni oggetto
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                
                // Aggiorna la posizione
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                // Controlla le collisioni con i bordi
                if (ball.x + ball.radius > multipleObjectsCanvas.width || ball.x - ball.radius < 0) {
                    ball.dx = -ball.dx;
                }
                if (ball.y + ball.radius > multipleObjectsCanvas.height || ball.y - ball.radius < 0) {
                    ball.dy = -ball.dy;
                }
                
                // Disegna la pallina
                multipleObjectsCtx.beginPath();
                multipleObjectsCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                multipleObjectsCtx.fillStyle = ball.color;
                multipleObjectsCtx.fill();
            }
            
            multipleAnimationId = requestAnimationFrame(animateMultiple);
        }
        
        // Controlli per l'animazione multipla
        document.getElementById('addBall').addEventListener('click', function() {
            balls.push(createBall());
            
            // Se non c'è animazione in corso, disegna le palline statiche
            if (!multipleAnimationId) {
                multipleObjectsCtx.clearRect(0, 0, multipleObjectsCanvas.width, multipleObjectsCanvas.height);
                for (const ball of balls) {
                    multipleObjectsCtx.beginPath();
                    multipleObjectsCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    multipleObjectsCtx.fillStyle = ball.color;
                    multipleObjectsCtx.fill();
                }
            }
        });
        
        document.getElementById('startMultipleAnimation').addEventListener('click', function() {
            if (!multipleAnimationId) {
                animateMultiple();
            }
        });
        
        document.getElementById('stopMultipleAnimation').addEventListener('click', function() {
            if (multipleAnimationId) {
                cancelAnimationFrame(multipleAnimationId);
                multipleAnimationId = null;
            }
        });
        
        document.getElementById('clearBalls').addEventListener('click', function() {
            balls.length = 0;
            multipleObjectsCtx.clearRect(0, 0, multipleObjectsCanvas.width, multipleObjectsCanvas.height);
        });
        
        // 4. Animazione con fisica semplice
        const physicsCanvas = document.getElementById('physicsCanvas');
        const physicsCtx = physicsCanvas.getContext('2d');
        let physicsAnimationId;
        const physicsBalls = [];
        const gravity = 0.2;
        const friction = 0.99;
        
        function createPhysicsBall() {
            return {
                x: Math.random() * physicsCanvas.width,
                y: Math.random() * (physicsCanvas.height / 2),
                radius: 10 + Math.random() * 10,
                dx: Math.random() * 4 - 2,
                dy: 0,
                color: `rgb(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)})`
            };
        }
        
        function animatePhysics() {
            physicsCtx.clearRect(0, 0, physicsCanvas.width, physicsCanvas.height);
            
            for (let i = 0; i < physicsBalls.length; i++) {
                const ball = physicsBalls[i];
                
                // Applica la gravità
                ball.dy += gravity;
                
                // Aggiorna la posizione
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                // Controlla le collisioni con i bordi laterali
                if (ball.x + ball.radius > physicsCanvas.width || ball.x - ball.radius < 0) {
                    ball.dx = -ball.dx * friction;
                    // Correggi la posizione per evitare che la palla si blocchi nel bordo
                    if (ball.x + ball.radius > physicsCanvas.width) {
                        ball.x = physicsCanvas.width - ball.radius;
                    } else if (ball.x - ball.radius < 0) {
                        ball.x = ball.radius;
                    }
                }
                
                // Rimbalzo sul fondo con perdita di energia
                if (ball.y + ball.radius > physicsCanvas.height) {
                    ball.y = physicsCanvas.height - ball.radius;
                    ball.dy = -ball.dy * friction;
                    
                    // Applica attrito anche alla velocità orizzontale quando tocca il suolo
                    ball.dx *= friction;
                }
                
                // Disegna la pallina
                physicsCtx.beginPath();
                physicsCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                physicsCtx.fillStyle = ball.color;
                physicsCtx.fill();
            }
            
            physicsAnimationId = requestAnimationFrame(animatePhysics);
        }
        
        // Controlli per l'animazione con fisica
        document.getElementById('addPhysicsBall').addEventListener('click', function() {
            physicsBalls.push(createPhysicsBall());
            
            // Se non c'è animazione in corso, disegna le palline statiche
            if (!physicsAnimationId) {
                physicsCtx.clearRect(0, 0, physicsCanvas.width, physicsCanvas.height);
                for (const ball of physicsBalls) {
                    physicsCtx.beginPath();
                    physicsCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    physicsCtx.fillStyle = ball.color;
                    physicsCtx.fill();
                }
            }
        });
        
        document.getElementById('startPhysicsAnimation').addEventListener('click', function() {
            if (!physicsAnimationId) {
                animatePhysics();
            }
        });
        
        document.getElementById('stopPhysicsAnimation').addEventListener('click', function() {
            if (physicsAnimationId) {
                cancelAnimationFrame(physicsAnimationId);
                physicsAnimationId = null;
            }
        });
        
        // 5. Animazione con easing
        const easingCanvas = document.getElementById('easingCanvas');
        const easingCtx = easingCanvas.getContext('2d');
        let easingAnimationId;
        
        // Funzioni di easing
        const easingFunctions = {
            // Movimento lineare
            linear: t => t,
            
            // Rallenta alla fine
            easeOut: t => 1 - Math.pow(1 - t, 3),
            
            // Rallenta all'inizio e alla fine
            easeInOut: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
            
            // Effetto rimbalzo
            bounce: t => {
                const n1 = 7.5625;
                const d1 = 2.75;
                
                if (t < 1 / d1) {
                    return n1 * t * t;
                } else if (t < 2 / d1) {
                    return n1 * (t -= 1.5 / d1) * t + 0.75;
                } else if (t < 2.5 / d1) {
                    return n1 * (t -= 2.25 / d1) * t + 0.9375;
                } else {
                    return n1 * (t -= 2.625 / d1) * t + 0.984375;
                }
            }
        };
        
        // Animazione con easing
        function animateWithEasing(easingFunction) {
            // Cancella eventuali animazioni in corso
            if (easingAnimationId) {
                cancelAnimationFrame(easingAnimationId);
            }
            
            let startTime = null;
            const duration = 2000; // 2 secondi
            const startX = 50;
            const endX = easingCanvas.width - 50;
            
            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Applica la funzione di easing
                const